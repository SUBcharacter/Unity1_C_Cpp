2-1
문제: 특정 문자 제거

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

char* solution(const char* my_string, const char* letter) {
    
    int length = strlen(my_string);
    int index = 0;
    char* array2[length];
    
    for(int i = 0; i<length;i++)
    {
        if(my_string[i] != letter[0])
        {
            array2[index] = my_string[i];
            index++;
        }
    }
    
    char* result = (char*)malloc(index + 1);
    
    for(int i = 0; i< index; i++)
    {
        result[i] = array2[i];
    }
    
    result[index] = '\0';
    
    
    return result;
}

- 핵심 로직 및 설명

필터링 된 만큼만 만드는것. my_string에서 타겟 문자를 제외한 문자를 담고있는 배열이 array2.
여기서 테스트 케이스 2번째 경우 처럼 타겟문자가 여러개가 있을 수 있으니
필터링 된 문자의 개수를 나타내는 index가 필요함. 지역 변수로 선언된 상태에서 배열의 앞주소를 넘기면
미정의 동작이 일어남으로 넘겨주는 배열은 동적할당이 필요하다.
따라서 result에 index를 이용한 동적할당을 해주고, 널문자 공간을 위해 +1을 해준다.
나머지는 문자를 옮겨주기만 하면 된다. 마지막 원소로 널문자를 넣어주면 완성.



2-2 : C# 문제 1
배열 자르기

using System;

public class Solution {
    public int[] solution(int[] numbers, int num1, int num2) {
        int length = num2 - num1 +1;
        int[] result = new int[length];
        
        for(int i =0; i < length ;i++)
        {
            result[i] = numbers[num1+i];
        }
        
        return result;
    }
}

-핵심 로직 및 설명
범위 내의 원소를 가져오는 것이 핵심. 그러면 일단 범위의 크기를 알아야하고,
그 크기에 맞게 자리를 만들어 주면 된다. num1 < num2 이니 범위의 크기는 num2 - num1 +1.
length에 초기화 시켜주고, length에 맞게 new int[]로 동적 할당해준다. 이후 for문으로 length 만큼 반복하는데
이때 복사과정에서 result[i] = numbers[num1+i]가 필요하다. num1은 범위의 첫 인덱스이다. 그곳에서 부터
length 만큼 반복 하면 범위내의 숫자들을 성공적으로 복사 가능하다. 반환 까지 해주면 끝.



2-3 : C# 문제 2
사용자 금지어 필터

using System;

public class Solution
{
    public string solution(string content, string bannedTags)
    {
        string[] words = content.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        string[] banned1 = bannedTags.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        string[] banned2 = bannedTags.Split(',', StringSplitOptions.RemoveEmptyEntries);

        foreach(string word in words)
        {
            foreach(string bannedTag in banned1)
            {
                if(word == bannedTag)
                {
                    return "BLOCK";
                }
            }
        }

        foreach (string word in words)
        {
            foreach (string bannedTag in banned2)
            {
                if (word == bannedTag)
                {
                    return "BLOCK";
                }
            }
        }

        return "ALLOW";
    }
}


-핵심 로직 및 설명
중요 포인트는 '어떻게 인식할 것인가?' 이다. content는 단순한 문장이 들어있다고 치지만, 
bannedTags는 다르다. 여러개가 동시에 있을 수도 있고, 어떤 방식으로 단어가 나뉘어져 있는지도 모른다.
제일 대표적인 공백과 콤마로 케이스를 나누어서 판단했다. Split옵션으로 아무런 값이 없는 것은 무시하도록
설정 해서, 순수하게 단어들 끼리로만 비교하도록 했다. 단어들을 각 배열에 넣어준다음, 공백문자로 나눈 케이스
콤마로 나눈 케이스들을 비교해서 한번 걸리면 "BLOCK"을, 전부 통과하면 ALLOW를 string으로 반환 하도록
했다.


2-4 : C++ 문제 1
문자열 내 p와 y의 개수

#include <string>
#include <iostream>
using namespace std;

bool solution(string s)
{
    int countp = 0;
    int county = 0;
    
    for(int i = 0; i< s.size();i++)
    {
        if(s[i] == 'p' || s[i] == 'P')
        {
            countp++;
        }
        else if(s[i] == 'y' || s[i] == 'Y')
        {
            county++;
        }
    }
    
    if(countp == county)
    {
       return true;
    }
    else if(countp != county)
    {
        return false;
    }
}


- 핵심 로직 및 설명
p와 y의 개수를 대소문자 구분 없이 대조하여 true/false를 반환 하는 bool타입 함수이다.
가장 중요한 점은 '대소문자 구분 없이'. p와 y의 경우를 대문자 또는 소문자로 나누어 or 로 연산하여 true라면
각각의 카운트를 1씩 증가 시킨다. 마지막은 카운터를 비교하여 조건에 맞으면 true 아니면 false로 반환한다.



2-5 : C++ 문제 2
해시맵을 활용한 중복 문자 제거

#include <iostream>
#include <unordered_map>
using namespace std;

string Solution(const string str)
{
    unordered_map<char, int> map;

    for (int i = 0; i < str.length(); i++)
    {
        map[str[i]] = i;
    }

    string result;

    for (int i = 0; i < str.length(); i++)
    {
        if (map[str[i]] == i)
        {
            result.push_back(str[i]);
        }
    }

    return result;
}


-핵심 로직 및 설명
해시맵은 내부적으로 hash<T>를 사용한다. 같은 키에서 충돌이 일어나면 덮어씌워지는 특성을 이용해
마지막으로 나온 문자를 추출한다. 문자열의 원소를 키로, 그것의 인덱스를 값으로 해서 제일 마지막에 나온
인덱스를 저장하게 된다. 이후 그에 맞춰 인덱스 값이 같다면 result에 넣어서 반환시키면 된다.

================================================================

3-1
문자열 안에 문자열

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

int solution(const char* str1, const char* str2) {
    int length1 = strlen(str1);
    int length2 = strlen(str2);
    
    for(int i = 0; i< length1 - length2 +1 ; i++)
    {
        bool exist = true;
        for(int j = 0; j < length2 ; j++)
        {
            if(str1[i+j] != str2[j])
            {
                 exist = false;
	     break;
            }
        }
        if(exist)
        {
            return 1;
        }
    }
    return 2;
}


- 핵심 로직 및 설명
사용한 로직은 슬라이딩 윈도우. 검사의 주체가 되는 str2를 한칸씩 옆으로 옮겨가며 str2의 크기 만큼 반복해서
원소를 비교하는 방식으로 진행했다. 각 배열의 크기를 구해서 변수에 넣어놓고, 슬라이딩 윈도우 시작.
exist를 기본 true로 해두고, 두 원소를 비교중 불일치가 나온다면 false로 만들고 중지, 다음 반복으로 넘어가게끔
했다. 결과적으로 전부 다 돌았을때 exist가 아직 true라면 존재 한다는 것이니 1을 반환, 다돌았는데도 없으면 2를
반환 한다.



3-2 : C# 문제 1
대문자와 소문자

using System;
using System.Text;

public class Solution {
    public string solution(string my_string) {
       
        StringBuilder result = new StringBuilder();
        
        for(int i = 0 ; i < my_string.Length ; i++)
        {
            if(char.IsUpper(my_string[i]))
            {
                result.Append(char.ToLower(my_string[i]));
            }
            else
            {
                result.Append(char.ToUpper(my_string[i]));
            }
        }
        return result.ToString();
        
    }
}


- 핵심 로직 및 설명
C#은 C++과 다르게 '불변' 속성을 가지고 있어서 push_back을 할 수 없다. 그래서 따로 만들기 위해서는 StringBuilder가 필요하다.
using System.Text를 선언해서 StringBuilder를 사용할 수 있게끔 만들고, 이를 이용해서 바꾼 문자열을 반환 한다.
my_string의 크기 만큼 반복하면서 각 원소가 대문자면 소문자로, 소문자면 대문자로 result에 저장되게끔 하고,
반환 할땐 ToString()을 써서 string으로 반환 시켜 준다.



3-3 : C# 문제 2
숫자 자동 집계 시스템

using System;
using System.Collections.Generic;
using System.Linq;

public class Solution
{
    public List<(int number, int count)> solution(int[] numbers)
    {
        Dictionary<int ,int> dict = new Dictionary<int, int> ();
        
        foreach(int i in numbers)
        {
            if(dict.ContainsKey(i))
            {
                dict[i]++;
            }
            else
            {
                dict[i] = 1;
            }
        }

        List<(int number, int count)> result = dict
            .OrderByDescending(pair => pair.Value)
            .Select(pair => (pair.Key, pair.Value))
            .ToList();

        return result;
    }
}

- 핵심 로직
Tuple은 수정이 안되는 '불변'속성을 가지고 있다. 따라서 다른곳에서 카운팅을 하고 그 값을 저장해야 한다.
Dictionary를 이용해 numbers의 숫자를 키값으로 받고, 있으면 숫자를 1올리고, 없으면 1을 저장한다.
Linq의 OrderByDescending을 이용해 count값 기준 내림차순 정렬해준 다음, Select를 이용해 튜플로 바꿔준다음
리스트로 변환 시켜주고 반환 하면 끝이다.



3-4 : C++ 문제 1
중복된 문자 제거

#include <string>
#include <unordered_map>

using namespace std;

string solution(string my_string) {
    
    unordered_map<char, int> map;
    string result;
    
    for(int i = 0; i< my_string.length() ; i++)
    {
        if(map.find(my_string[i]) == map.end())
        {
            map[my_string[i]] = i;
            result.push_back(my_string[i]);
        }
    }
    return result;
}


- 핵심 로직 및 설명
설명을 적으면서 든 생각이지만, 해시맵이 아니라 일반 맵을 써도 됐을것 같다는 생각이 들었다.
다만 쓸데없는 동작이 있을 것 같아 해시맵을 사용했다.
my_string의 원소를 비교 하면서 그 문자가 해시맵에 존재하는지 확인 후, 없으면 인덱스와 함께 추가,
result에 바로 넣어 버린다. 결과적으로 첫 등장한 문자만 순서대로 result에 들어가서 반환 된다.



3-5 : C++ 문제 2
괄호 내 문자열 뒤집기

#include <string>
#include <vector>

using namespace std;

vector<int> solution(vector<int> arr) {
    
    vector<int> stk;
    
    for(int i = 0; i< arr.size(); i++)
    {
        if(!stk.empty() && stk.back() == arr[i])
        {
            stk.pop_back();
        }
        else
        {
            stk.push_back(arr[i]);
        }
    }
    
    if(!stk.empty())
    {
        return stk;
    }
    else
    {
        stk.push_back(-1);
        return stk;
    }
}


- 핵심 로직 및 설명
조건의 분기를 잘 보면 stk의 마지막 요소가 같은 경우에는 같은 행동을 한다.
쓸데없이 분기를 만들기 보다는 한번에 통일해서 처리하는 것이 가독성에 더 좋다고 생각했다.
arr의 크기만큼 반복하는 동안 stk이 비지 않은 상태에서 마지막 요소가 arr[i]와 같으면 없애버리고,
나머지의 경우에는 그냥 넣어주기로 했다. 
마지막에 함정이 있는데, stk이 빈 상태가 아니라면 그대로 반환 하고, 비어있다면 [-1]을 반환해야하는데,
-1을 stk안에 넣어주고 반환 시켜야한다. 반환형이 vector<int>이므로 vector안에다 넣어준다음 반환해야
오류가 나지 않는다.

=================================================================

4-1
OX퀴즈 판별기

char* Solution(const char* question)
{
	int x1, y1, z1;
	float x2, y2, z2;
	char op;
	
	if (sscanf(question, "%d %c %d = %d", &x1, &op, &y1, &z1) == 4)
	{
		switch (op)
		{
		case '+': return (x1 + y1 == z1) ? "O" : "X"; break;
		case '-': return (x1 - y1 == z1) ? "O" : "X"; break;
		case '*': return (x1 * y1 == z1) ? "O" : "X"; break;
		case '/': return (y1 != 0 && x1 / y1 == z1) ? "O" : "X"; break;
		}
	}
	else if (sscanf(question, "%d %c %f = %f", &x1, &op, &y2, &z2) == 4)
	{
		switch (op)
		{
		case '+': return (x1 + y2 == z2) ? "O" : "X"; break;
		case '-': return (x1 - y2 == z2) ? "O" : "X"; break;
		case '*': return (x1 * y2 == z2) ? "O" : "X"; break;
		case '/': return (y2 != 0 && x1 / y2 == z2) ? "O" : "X"; break;
		}
	}
	else if (sscanf(question, "%f %c %d = %f", &x2, &op, &y1, &z2) == 4)
	{
		switch (op)
		{
		case '+': return (x2 + y1 == z2) ? "O" : "X"; break;
		case '-': return (x2 - y1 == z2) ? "O" : "X"; break;
		case '*': return (x2 * y1 == z2) ? "O" : "X"; break;
		case '/': return (y1 != 0 && x2 / y1 == z2) ? "O" : "X"; break;
		}
	}
	else if (sscanf(question, "%f %c %f = %f", &x2, &op, &y2, &z2) == 4)
	{
		switch (op)
		{
		case '+': return (x2 + y2 == z2) ? "O" : "X"; break;
		case '-': return (x2 - y2 == z2) ? "O" : "X"; break;
		case '*': return (x2 * y2 == z2) ? "O" : "X"; break;
		case '/': return (y2 != 0 && x2 / y2 == z2) ? "O" : "X"; break;
		}
	}
}


- 핵심 로직 및 설명
내가 짠 코드중에서 가장 더러운 코드라고 볼 수 있을 것 같다.
더러워진 이유는 단 하나. 문제에는 숫자가 어떤 자료형이 들어올지를 알려주지 않았다. 그렇기에
임의로 int와 float의 경우를 전부 판단해서 작성하였다. 이 부분 양해 바람.
첫번째로 int형의 숫자들과 float형의 숫자들, 연산자를 받아올 char 변수까지 선언해주고,
sscanf를 통해 question의 포맷대로 각 숫자와 연산자를 변수에 저장 시키고, 제대로 되었다면 if문으로 진입
만약 자료형이 달라 하나라도 잘못 받아오게 되면 4가 아니게 될테니 다음 포맷으로 가서 검사하도록 설계했다.
다음, 받아온 연산자를 switch문으로 숫자들을 연산한 결과(bool)를 삼항 연산자로 판단해서 맞으면 O, 틀리면 X
char* 로 반환 해주게끔 했다.



4-2 : C# 문제 1
숫자 문자열 정렬 + 유효성 필터

public int[] solution(string my_string)
{
    List<int> list = new List<int>();

    for (int i = 0; i < my_string.Length; i++)
    {
        if (char.IsDigit(my_string[i]))
        {
            list.Add(my_string[i] - '0');
        } 
    }

    list.Sort();

    int[] result = new int[list.Count];

    for(int i = 0; i < list.Count;i++)
    {
        result[i] = list[i];
    }

    return result;
}


- 핵심 로직 및 설명
일단 숫자를 받아 정렬 시켜줄 List<int>를 만들고, 
my_string의 원소들을 읽어 숫자라면 int형으로 바꿔서 넣어준다.
그다음 sort()함수를 이용해서 오름차순 정렬해주고, list의 크기만큼 정수배열을 만들어
차례차례 넣어주고 반환 해주면 끝이다.



4-3 : C# 문제 2
사용자의 사운드 설정을 저장하고 불러오는 클래스를 설계하세요.

public class SoundOption
{
    float BGM = 100.0f;
    float SE = 100.0f;

    public void LoadSetting(Dictionary<string,float> dict)
    {
        int index = 0;
        float[] values = new float[2];

        foreach(var key in dict.Keys)
        {
            values[index++] = dict[key];
        }

        BGM = values[0];
        SE = values[1];
-------------------------------------------  둘중 하나로 해도 됨
	BGM = dict["BGM"];
	SE = dict["SE"];

    }

    public Dictionary<string,float> SaveOption()
    {
        var saveOption = new Dictionary<string,float>();

        saveOption["BGM"] = BGM;
        saveOption["SE"] = SE;

        return saveOption;
    }

    public void SetBGMVolume(float rate)
    {
        BGM = rate;
    }

    public void SetSEVolume(float rate)
    {
        SE = rate;
    }
}


- 핵심 로직 및 설명
설명에 앞서서 딕셔너리 위주로 저장, 불러오기를 구현했다.
일단 BGM, SE 수치를 저장할 float형 변수를 선언해서 비교를 위한 기본값 100을 넣어 주었다.
BGM과 SE를 설정해주는 함수는 거의 한줄로 끝나기 때문에 어려울게 없었다.
문제는 Dictionary. 통계 강의를 들으면서 어렴풋이 기억나는 형식이지만, 용법을 모른다.
따라서 검색해본 결과, map과 상당히 유사한 용법을 가지고 있었기에, 반환만 제대로 해준다면 SaveOption함수는 어렵지 않았다. 
LoadSetting은 key값 별로 값을 가져오면 된다. 현재 두가지 방법을 적어두었는데, 하나는 for문으로 딕셔너리의 키값을 돌면서 지역배열에 저장하고 그 값을 두 멤버변수에 넣어주는 식이다. 다른 한가지는 그냥 직접 일일이 쓰는것. 나쁜 방법은 아니지만, 이 두가지 경우는
딕셔너리에 무슨 값이 어떤 순서로 들어있을지를 알고 있어야 한다.  형식이 조금이라도 달라지거나 하면 사용하기 까다로워진다는 것.
이부분은 조금더 공부가 필요하다고 판단된다. 이후 Main() 함수에서 선언 후 실행하니 값 변경도 잘 이루어지고, 저장도 잘되는 것을
확인했다.



4-4 : C++ 문제 1
정수 n이 매개변수로 주어질 때, n 이하의 홀수가 오름차순으로 담긴 배열을 return하도록 solution 함수를 완성해주세요.

#include <string>
#include <vector>

using namespace std;

vector<int> solution(int n) {
    vector<int> answer;
    
    for(int i = 1; i<=n ; i++)
    {
        if(i%2 != 0)
        {
            answer.push_back(i);
        }
    }
    
    
    return answer;
}


- 핵심 로직 및 설명
간단한 문제라 설명할 것도 별로 없다. n을 받아와서 n이하의 홀수만 가려내면 될 일. 배열은 동적배열인 vector<int>를 사용했다. 
단순히 for문을 n만큼 돌려서 i를 나눈 나머지가 1이면 배열에다 순서대로 넣어주면 끝나는 일이다. 그걸 그대로 반환 해주면 끝이다.



4-5 : C++ 문제 2
간단한 키입력 처리기 설계

#include <iostream>
#include <unordered_map>
using namespace std;

class InputHandler
{
public:
    InputHandler() {}

    string HandleKey(char key)
    {
        switch (key)
        {
        case 'W':
        case 'w': return "UP";
            break;
        case 'A':
        case 'a': return "LEFT";
            break;
        case 'S':
        case 's': return "DOWN";
            break;
        case 'D':
        case 'd': return "RIGHT";
            break;
        default:
            break;
        }
    }
};

int main()
{
    InputHandler IH;
    char key;

    while (cin >> key)
    {
        cout << IH.HandleKey(key) << endl;
    }
}

- 핵심 로직 및 설명
이것도 간단. 단순히 char형의 키값을 받아서 맞는 스트링으로 골라서 반환 해주면 끝.
HandleKey는 char형의 키 값을 받아오게 되어있고, 내부로 들어가면 switch문으로 들어가서 알맞는 값으로 바뀌어 나온다.
대소문자 구분없이 인식하도록 switch문의 특성을 잘 이용해서 리턴 해주도록 바꾸었고, 해당하는 키값 이외의 것이 들어올것을 우려하여
default로 아무것도 동작하지 않도록 처리를 해주었다. 이후 main()함수에서 선언후, while루프를 돌때마다 키값을 입력하면, 맞는 방향을
출력해주게끔 해주었다. 작동은 잘된다.

=================================================================

5-1
문제: A로 B만들기

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

int solution(const char* before, const char* after) {
    int size = strlen(before);
    
    if(size != strlen(after))
    {
        return 0;
    }
    
    int ascii[256] = {0};
    
    for(int i =0; i<size; i++)
    {
        ascii[before[i]]++;
        ascii[after[i]]--;
    }
    
    for(int i =0; i< 256 ; i++)
    {
        if(ascii[i] != 0)
        {
            return 0;
        }
    }
    
    return 1;
}

- 핵심 로직 및 설명
핵심은 'before의 요소들이 after의 요소들과 똑같은가?' 이다. 요소들이 전부 같다면 after를 만들 수 있는 조건이 갖추어진다.
문제는 'before이 after가 될 수 있나요?' 를 물어본것. 그렇다면 각 요소들의 등장횟수를 알아낸다면 요소들이 똑같다는 것이다.
ascii코드를 이용할 것인데, 아스키 코드는 숫자로도 표현이 가능하다. 따라서 int형의 배열을 아스키 코드만큼의 크기로 설정하고,
for문을 돌려 before와 after의 요소가 ascii 배열의 인덱스와 일치하는 곳에다 +1과 -1을 해준다. 
등장횟수가 같다면 마지막에는 ascii배열은 모두 0만 들어가 있을 것이기 때문에, 이를 이용하는 것이다.
나머지는 ascii배열을 순회하면서 0이 아니라면 즉각 0을 반환하고 무사히 순회 했다면 1을 반환해주면 끝이다.



5-2 : C# 문제 1
소문자 변환

using System;
using System.Text;

public class Solution {
    public string solution(string myString) {
        StringBuilder result = new StringBuilder();

        for(int i = 0; i< myString.Length; i++)
        {
            result.Append(char.ToLower(myString[i]));
        }

        return result.ToString();
    }
}

- 핵심 로직 및 설명
C#에는 StringBuilder가 있었다. 전에도 설명했듯, C#의 string은 '불변' 속성을 가지고 있다. 읽기 전용이라는 뜻. 따라서 새로운 공간을 만들어서 저장해야하는데, 그것이 StringBuilder의 역할이다. 하는 법은 너무 간단하다. StringBuilder로 선언된 result에 myString의 한자씩,
char.ToLower()함수로 만들어서 Append로 추가해주면 된다. 마지막에는 ToString()으로 string으로 변환 시킨후 반환 하면 끝이다.



5-3 : C# 문제 2
UI 창 여러 개 중 하나만 활성화되는 상태 전환 구조를 설계하세요.

public class UIManager
{
    Dictionary<string, bool> UIlist;

    public UIManager()
    {
        UIlist = new Dictionary<string, bool>();

        UIlist["Health"] = true;
        UIlist["Mana"] = true;
        UIlist["Pause"] = true;
        UIlist["EXP"] = true;
    }

    public void open(string name)
    {
        foreach(var key in UIlist.Keys)
        {
            if(key != name)
            {
                UIlist[key] = false;
                Console.WriteLine(key + "비활성화!");
            }
            else
            {
                UIlist[key] = true;
                Console.WriteLine(key + " 활성화!");
            }
            Console.Write("\n");
        }
    }
}

- 핵심 로직 및 설명
UI들을 담아두는 곳은 Dictionary<string,bool>로 했다. 이유는 두가지. 딕셔너리는 어느정도 다루기 쉬웠고, 키값에 따른 활성화 여부를 보기 위해선, 이름에 맞게 작동시킬 필요가 있으므로 string과 bool을 사용했다.
UIlist를 선언해서 UI들을 저장할 공간을 만들어주고, 기본 생성자를 만들어서 초기화를 해주었다. 멤버변수로 선언만 하게되면, 공간 할당이 안되기에, 실수로 접근하면 미정의 동작으로 이어질 수 있다. 따라서 기본 생성자에서 new DIctionary<>()를 해주고, 간단하게 UI키 들을 넣어서 true로 넣어주었다.
이제 open()으로 넘어가서, foreach문을 사용해서 받아온 name을 키값과 비교한다. 같다면 해당 키를 true로 만든뒤 활성화 되었다는 출력을, 틀리다면 false로 만든 후, 상태를 출력 하게끔 했다.



5-4 : C++ 문제 1
배열 자르기

#include <string>
#include <vector>

using namespace std;

vector<int> solution(vector<int> numbers, int num1, int num2) {
    vector<int> answer;
    
    for(int i = num1 ; i <= num2 ; i++)
    {
        answer.push_back(numbers[i]);
    }
    
    return answer;
}

- 핵심 로직 및 설명
이전 C#으로 풀어본 문제이다. int형의 numbers를 넘겨 받아서 num1번째 인덱스 부터 num2번째 인덱스까지 추출하여 반환 하는 함수를 만들면 되는 문제이다.
int 형의 vector를 선언해주고, for문으로 반복하는데, num1 부터 num2까지 가는동안 answer에다 해당 요소를 추가해주면 된다.
마무리로 반환까지.



5-5 : C++ 문제 2
상태 머신 기초 구조

enum State
{
    IDLE,
    RUNNING,
    JUMPING
};

class Player
{
private:
    State state;

public:
    Player()
    {
        state = IDLE;
    }

    void ChangeState(string newState)
    {
        if (newState == "IDLE")
        {
            state = IDLE;
            cout << "Current State : " << newState << endl;
        }
        else if (newState == "RUNNING")
        {
            state = RUNNING;
            cout << "Current State : " << newState << endl;
        }
        else if (newState == "JUMPING")
        {
            state = JUMPING;
            cout << "Current State : " << newState << endl;
        }
        else
        {
            cerr << "State Doesn't Exist" << endl;
        }
    }
};

- 핵심 로직 및 설명
서로 다른 속성을 가진 상태를 표현 하기 위해서는 가독성과 인식하기 편한 열거형을 쓰는것이 좋다고 생각했다.
따라서 State라는 열거형을 만들고, Player클래스 멤버변수에 추가했다. 생성자에서 초기화 값은 임의적으로 IDLE로 정해두었다.
ChangeState() 함수는 string형의 문자열을 받아, 문자열이 뜻하는 상태로 갱신해주는 함수이다. 
처음에는 switch 문을 사용하려 했으나, string을 조건으로 넣을 수는 없었으므로, 단순한 조건문으로 처리하기로 했다.
각 상태에 따른 분기를 만들고, 해당 분기에 들어서면 state를 갱신하고, 로그를 출력한다. 해당하는 상태가 없다면 갱신되지 않고, 오류메세지가 출력되게 했다.

=================================================================

여섯번째 과제가 다섯번째 과제의 문제와 내용이 같음, 따라서 굳이 한번더 작성하지 않음

=================================================================

7-1 : C 공통문제
스케줄 충돌 감지기
#include <stdio.h>
#include <stdbool.h>

bool ScheduleConflict(int schedule[][2], int size)
{
	int startTime = 25;
	int finishTime = 0;

	for (int i = 0; i < size; i++)
	{
		if (schedule[i][0] < startTime)
			startTime = schedule[i][0];
		if (schedule[i][1] > finishTime)
			finishTime = schedule[i][1];
	}

	int timeLine[24] = { 0 };

	for (int i = 0; i < size; i++)
	{
		for (int j = schedule[i][0]; j < schedule[i][1]; j++)
		{
			timeLine[j]++;
		}
	}

	for (int i = startTime; i < finishTime; i++)
	{
		if (timeLine[i] > 1)
		{
			return true;
		}
	}
	return false;
}

int main()
{
	int schedule[3][2] = { {9, 11}, {13, 15}, {10, 12} };

	int size = sizeof(schedule) / sizeof(schedule[0]);

	if (ScheduleConflict(schedule, size))
	{
		printf("스케쥴 충돌 감지");
	}
	else
	{
		printf("스케쥴 충돌 없음");
	}

	return 0;
}

- 핵심 로직 및 설명
일단 중요한건 2차원 배열의 행 수를 알아내는것이 제일 중요한데, 매개변수로 받는 이상 포인터가 되어버려, sizeof를 이용한 방법은 힘들어진다.
따라서 매개변수를 추가하여 사이즈를 받아오게끔 해준다.
이 함수의 목적은 스케쥴의 배열을 받아와서 구간별로 검사 후 겹치는 스케쥴이 있는지를 판별하기 위해서이다. 
따라서 bool타입으로 true, false를 반환하여 차후 확장시에 활용성을 높일 수 있게끔 했다.
첫번째로 전체 스케쥴이 언제 시작해서 언제 끝나는지를 알아야 한다. 그래서 startTime, finishTime을 만들어서,
for문 으로 각 스케쥴별로 최하, 최상 시간을 구한다. 스케쥴 시작시간이 startTIme보다 낮으면 갱신, finishTime도 똑같이 해준다.
다음으로 timeLine이라는 int형 배열을 만들어준다. 이 배열은 인덱스를 시간축으로 해서, 각 구간별 스케쥴의 개수를 기록하기 위함이다.
만약 timeLine의 요소에 1보다 큰 수가 들어가 있다면 그곳은 스케쥴이 겹쳐졌다고 볼 수 있다.
for문을 돌려서 각 스케쥴별 구간에 따라 timeLine에 +1씩 해주고, 이후, 먼저 구해줬던 startTime과, finishTime을 돌며 timeLine에 해당하는 인덱스에서 1보다 큰 숫자를 발견하면 true를, 문제없이 순회했다면 false를 반환 해준다. main함수에서 이와 같이 사용할 수 있다.



7-2 : C# 문제 1
퀘스트 우선순위 정렬기

struct Quest : IComparable<Quest>
{
    public string name;
    public int difficulty;
    public bool isUrgent;

    public int CompareTo(Quest other)
    {
        int urgent = other.isUrgent.CompareTo(this.isUrgent);
        if (urgent != 0)
        {
            return urgent;
        }
        return other.difficulty.CompareTo(this.difficulty);
    }
}

public static void Main()
{
    Quest[] quests = new Quest[]
    {
        new Quest {name = "채집", difficulty = 3, isUrgent = false },
        new Quest {name = "긴급출동", difficulty = 5, isUrgent = true},
        new Quest {name = "보스전", difficulty = 9, isUrgent = false},
        new Quest {name = "방어", difficulty = 7, isUrgent = true},
    };

    Array.Sort(quests);

    for(int i = 0; i<quests.Length; i++)
    {
        Console.WriteLine(quests[i].name);
    }
}

- 핵심 로직 및 설명
이번 문제는 C#을 어느 정도 다뤄보지 않았다면 꽤 힘들것이라 생각이 든다. 나 또한 꽤 힘들게 풀었다.
구조체를 특정 조건에 맞게끔 정렬하는것이 주목표인데, 비슷한 것을 알고 있다. 
엑셀은 특정 조건, 여러개 조건에 맞게 정렬할 수 있는 기능이 있다. 
이것이 생각나서, 정렬에 관한 것들을 좀 찾아봤다. 
사용할 주요 함수는 Array.Sort(). 하지만 정렬조건을 주지 않으면 제대로 정렬이 되지 않는다. 
따라서 정렬 조건을 주어야 하는데, 이 정렬조건을 주는 방법은 여러개가 있지만, 나는 구조체 안에 CompareTo라는 함수를 만들어 줬다. CompareTo함수는 객체와 객체간에 우열을 가릴때 int형으로 그 우열을 반환 해준다. 
a와 b 객체가 있다면 음수는 a<b, 양수는 a>b, 0이라면 a=b가 된다. 
a.CompareTo(b)가 되었을때 음수가 나온다면, a가 b보다 작다는 뜻이므로, 정렬시에 앞쪽으로 오게 된다. 기본적으로 오름차순을 위한 함수인 것.
문제의 정렬 조건은, '긴급도가 있는 것 먼저'->'난이도 먼저' 순이다. 맨처음으로 판단해야 할것은 isUrgent이고, 그다음 difficulty를 비교해야한다. 
중요 포인트는 우리가 원하는 것은 내림차순, CompareTo는 오름차순이 기준이므로, this와 other의 위치를 바꿔주면 오름차순으로 바뀌게 된다. bool형은 내부적으로 1(true)과 0(false)로 되어 있기 때문에 비교가 가능하다. 먼저 isUrgent를 비교하고, 이후, difficulty를 비교해 높은것부터 정렬한다. 이후 Main함수에 와서 Array.Sort만 불러주면 기준에 따라서 정렬되고, 출력까지 해주었다.



7-3 : C# 문제 2
데이터 동기화 매니저 설계

public class SyncManager
{
    public Dictionary<string, int> clientData;
    public Dictionary<string, int> serverData;

    public SyncManager()
    {
        clientData = new Dictionary<string, int>();
        serverData = new Dictionary<string, int>();

        clientData["AP"] = 50;
        clientData["Level"] = 89;
        clientData["Gold"] = 150000;
    }

    public void Sync(Dictionary<string, int> dict)
    {
	UpdateData(dict)
        clientData = serverData;
        Console.WriteLine("서버 동기화 완료");
    }

    public void UpdateData(Dictionary<string, int> dict)
    {
        serverData = dict;
        Console.WriteLine("서버로 부터 데이터 받아오는 중...");
    }
}

public static void Main()
{
    Dictionary<string, int> data = new Dictionary<string, int>();
    data["AP"] = 100;
    data["Level"] = 90;
    data["Gold"] = 200000;

    SyncManager syncManager = new SyncManager();

    Console.WriteLine(syncManager.clientData["AP"]);
    Console.WriteLine(syncManager.clientData["Level"]);
    Console.WriteLine(syncManager.clientData["Gold"]);

    syncManager.Sync(data);

    Console.WriteLine(syncManager.clientData["AP"]);
    Console.WriteLine(syncManager.clientData["Level"]);
    Console.WriteLine(syncManager.clientData["Gold"]);
}

- 핵심 로직 및 설명
문제의 전제 조건은 '서버로 부터 받아온 데이터를 클라이언트에 동기화 시킬것'이다. 때문에 서버로 부터 받아온 데이터를 저장해서 클라이언트에 적용시키는 과정이 필요하다.
UpdateData는 서버로 부터 받아온 딕셔너리 데이터를 SyncManager의 serverData에 저장 시키는 용도이다. 현재 시점의 서버 데이터를 저장하는 이유는, 실시간으로 서버로 부터 직접 데이터를 받을 경우, 서로 다른 시점의 데이터를 받아 들이게 된다. 따라서 특정 시점의 데이터를 받을 수 없어, 데이터들간 시간차가 생겨버린다. 따라서 특정 시점의 데이터를 한번에 받고 저장한 뒤 클라이언트와 동기화 시키는것이 안정적일거라 생각했다.
이후 Sync()함수를 사용해 UpdateData함수 실행후 동기화 작업, 로그 까지 전부 띄우게 한다.
Main함수에서는 실험을 위해 임시로 데이터를 만들어서 동기화 하는 작업을 진행했다.



7-4 : C++ 문제 1
최빈값 구하기

#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

int solution(vector<int> array) {
    
    unordered_map<int,int> map;
    
    for(auto a : array)
    {
        map[a]++;
    }
    
    int result = 0;
    int count = 0;
    bool multi = false;
    
    for(auto m : map)
    {
        if(m.second > count)
        {
            count = m.second;
            result = m.first;
            multi = false;
        }
        else if(m.second == count)
        {
            multi = true;
        }
    }
    
    if(multi)
    {
        return -1;
    }
    
    return result;
}

- 핵심 로직 및 설명
숫자별 빈도를 기록하는 것이 이번 문제의 핵심이다. 그를 위해선 키와 값으로 분류해서 숫자별로 빈도수를 셀 필요가 있다. 
이를 위해서 unordered_map을 사용했다. vector의 크기가 얼마나 될지 모르고, 일반 map으로는 탐색속도가 그다지 좋지 않아서 선택했다.
vector에서 뽑아낸 숫자를 키값으로 해서 빈도수를 저장해야 한다. for문으로 vector를 순회 하면서 키값과 동시에 빈도수를 계산한다.
그다음, 최빈값을 저장할 result, 빈도수를 비교할 count, 중복 최빈값을 판단할 multi를 선언 해주고, map을 순회 하면서,
이전에 저장되어있던 최빈값의 빈도수보다 높다면 업데이트와 함께 multi를 비활성화 시켜준다. 만약 최빈값이 겹친다면, multi를 기준으로 해서 추후 -1을 반환 할 것이다. for문이 끝났다면 중복최빈값이 있는지를 확인하고 없다면 그대로 result를 반환 해주면 된다.



7-5 : C++ 문제 2
게임 내 다양한 객체에 입력을 매핑하는 시스템을 설계하세요.

#include <iostream>
#include <Windows.h>

using namespace std;

class Component
{
public:
    Component() {}

    virtual void Update() = 0;
    virtual void Move() = 0;
    virtual void Jump() = 0;

    ~Component() {}
};

class InputComponent : public Component
{
public:
    InputComponent() {}

    void Move() override
    {
        if (GetAsyncKeyState(VK_LEFT))
        {
            cout << "왼쪽" << endl;
        }
        else if (GetAsyncKeyState(VK_RIGHT))
        {
            cout << "오른쪽" << endl;
        }
    }

    void Jump() override
    {
        if (GetAsyncKeyState(VK_SPACE))
        {
            cout << "점프" << endl;
        }
    }

    void Update() override
    {
        Move();
        Jump();
    }
    
    ~InputComponent() {}
};

int main()
{
    Component* input = new InputComponent();

    while (true)
    {
        input->Update();
        Sleep(500);
    }
    delete input;
}

-핵심 로직 및 설명
그다지 특별히 주요한 포인트는 없다. 다만, 상속을 얼마나 잘 이해하고 있는가가 이번 문제의 목적이다.
Component라는 클래스를 부모로 수많은 컴포넌트를 만들어 낼 수 있게끔 하는 것이 상속이다. 
이번에 만드는 것은 입력을 담당하는 컴포넌트이다. 다형성을 위한 껍데기 부모를 만들어 놓고, InputComponent를 만들어 상속 시켜준다.
이후 Move() 함수와 Jump()함수를 만드는 것인데, 상속된 클래스를 어떻게 쓸지가 관건이다. 포인터로 불러내어서 그곳에다 자식을 할당 시키느냐, 아니면 그냥 자식을 불러서 쓰느냐 둘중 하나 인데, 부모 포인터를 기준으로 자식들을 불러오는 것은 편의성 면에서 매우 좋다.
단순히 부모 포인터를 선언해주면 상속된 모든 클래스들을 뽑아 사용할 수 있기 때문인데, 이러한 다형성을 이용해서 작업할 것이기 때문에,
공통된 함수들을 먼저 가상 함수로 만들어 주고, 이후, 상속된 InputComponent에 해당하는 함수를 설계해주면된다. 이번 문제의 목적은
'키 입력시 객체가 잘 작동 하는가'에 있으므로, 단순하게 키를 입력 받았을때 해당하는 로그가 출력되도록 했다. Update() 함수를 다시 만들어서 move와 jump를 한번에 작동 시킬 수 있도록 해주고, 이를 토대로 main에서 작동시키도록 했다. 결과는 만족스럽게 잘 나왔다.
각 생성자와 소멸자에 대한 이야기가 빠졌는데, 따로 특별히 선언한 멤버변수도 없고, 동적 할당 시킨 멤버도 없기에, 단순하게 메인에서 포인터로 선언된 input을 delete해주면 메모리 걱정은 없다. 만약, 이런 클래스들을 다른 클래스에다 적용 시킨다면 동적할당 후 사용할 것인데, 그럴때에는 적절하게 소멸자에 delete를 해주면 누수는 일어나지 않는다.

=================================================================

8-1 
배치 가능한 작업 그룹 수 구하기

int main()
{
	int tasks[6] = { 20, 40, 30, 15, 10, 60 };
	int size = sizeof(tasks) / sizeof(int);

	int groupCount = 0;
	int taskTime = 0;
	int taskCount = 0;

	for (int i = 0; i < size; i++)
	{
		if (taskTime + tasks[i] <= 60 && taskCount < 3)
		{
			taskTime += tasks[i];
			taskCount++;
		}
		else
		{
			groupCount++;
			taskTime = tasks[i];
			taskCount = 1;
		}
	}
	if (taskTime > 0)
	{
		groupCount++;
	}

	printf("%d", groupCount);

	return 0;
}

- 핵심 로직 및 설명
핵심 : 작업시간이 60을 넘어가거나, 작업 수가 3을 넘어가면 새 그룹을 만들게끔 하는것
설명 :
배열 안의 수들을 최대 3개까지 짝지어서 총 합이 60을 넘어가게끔 하지 않으면 된다.
그룹의 총 수를 세는 변수, 그룹당 작업 수, 총 시간을 저장하는 변수, 총 3개의 변수를 활용한다.
for문으로 각 요소를 순회하면서 taskTime의 크기가 60보다 작고, taskCount가 3보다 작을 경우
taskTime에 요소를 더하고, taskCount를 하나 올린다. 조건중 하나라도 만족하지 못하면 새 그룹이 생겨야 함으로,
groupCount를 하나 올리고, 현재 요소를 시작점으로 초기화 한다.



8-2 : C# 문제 1
일정 예약 충돌 탐지기

public class Scheduler
{
    public Dictionary<string,List<int>> schedules;

    public Scheduler()
    {
        schedules = new Dictionary<string, List<int>>();
    }

    public void AddSchedule(string name, int start, int end)
    {
        if(schedules.Count > 0 )
        {
            int[] timeLine = new int[24];

            foreach(var key in schedules.Keys)
            {
                for(int i = schedules[key][0]; i < schedules[key][1]; i++)
                {
                    timeLine[i]++;
                }
            }

            for(int i = start; i <end; i++)
            {
                timeLine[i]++;
            }

            for(int i = 0; i < timeLine.Length; i++)
            {
                if (timeLine[i] >= 2)
                {
                    Console.WriteLine("스케쥴 충돌 감지 : 스케쥴을 추가 할 수 없습니다.");
                    return;
                }
            }

            schedules[name] = new List<int>();
            schedules[name].Add(start);
            schedules[name].Add(end);

            Console.WriteLine("스케쥴 추가 완료");
        }
        else
        {
            schedules[name] = new List<int>();
            schedules[name].Add(start);
            schedules[name].Add(end);

            Console.WriteLine("스케쥴 추가 완료");
        }
    }
}

- 핵심 로직 및 설명
핵심 : 추가 할 스케쥴의 시간대를 먼저 검사 후 추가
설명 :
스케쥴을 담아 둘 곳은, Dictionary이다. string으로 키를 만들고, List<int>로 시간대를 저장 할 수 있게끔 했다.
생성자에서 공간을 만들어 준 다음 작업을 시작한다.
AddSchedule은 string형의 이름, 시작 시간, 종료 시간을 매개변수로 받아온다.
검사에 들어가기 전에, 스케쥴의 수가 0 이상 인지를 확인한다. 0이라면 검사할 것이 없으니 바로 추가한다.
스케쥴의 수가 0이상 이라면, timeLine을 만들어 각 스케쥴에 해당하는 요소에 +1을 해주고,
마지막으로 추가할 스케쥴의 타임라인을 추가해준다.
이후 timeLine을 순회하면, 겹치는 곳의 요소는 무조건 2 이상의 값을 가지고 있을 것이다.
AddSchedule은 이 검사를 통과하지 못하면 스케쥴에 추가 되지 않기 때문에, schedules에는 겹치는 스케쥴이 없다.
하지만 새로 들어온 스케쥴이 기존 스케쥴과 겹치게 되면 감지할 수 있기에, 충돌을 감지하면 스케쥴을 추가하지 않고,
리턴 시켜서 추가하지 않게끔 한다.
검사를 통과 했다면 스케쥴이 등록 된다. 각 상황에 맞게 로그도 출력 된다.



8-3 : C# 문제 2
 네트워크 패킷 큐 시뮬레이터

public class PacketManager
{
    public Queue<string> packetQueue;

    public PacketManager()
    {
        packetQueue = new Queue<string>();
    }

    public void EnqueuePacket(string packet)
    {
        if(packetQueue.Count >= 10)
        {
            packetQueue.Dequeue();
            packetQueue.Enqueue(packet);
        }
        else
        {
            packetQueue.Enqueue(packet);
        }
    }

    public void ProcessPacket()
    {
        if(packetQueue.Count == 0)
            return;

        Console.WriteLine("[처리됨]" + packetQueue.Dequeue());
    }
}

public class Program
{
    public static void Main()
    {
        var packetManager = new PacketManager();

        packetManager.EnqueuePacket("채팅 1");
        packetManager.EnqueuePacket("채팅 2");
        packetManager.EnqueuePacket("채팅 3");
        packetManager.EnqueuePacket("채팅 4");
        packetManager.EnqueuePacket("채팅 5");
        packetManager.EnqueuePacket("채팅 6");
        packetManager.EnqueuePacket("채팅 7");
        packetManager.EnqueuePacket("채팅 8");
        packetManager.EnqueuePacket("채팅 9");
        packetManager.EnqueuePacket("채팅 10");
        packetManager.EnqueuePacket("채팅 11");

        for(int i = 0; i < 10; i++)
        {
            packetManager.ProcessPacket();
        }
    }
}

- 핵심 로직 및 설명
핵심 : Queue의 활용법 숙지
설명 :
Queue의 활용법 만 안다면 다루는 것은 너무 쉽다.
받아오는 데이터는 string형 이므로, Queue<string>형의 멤버 변수를 만들어서 초기화 해준다.
EnqueuePacket은 string형의 데이터를 받아와서 내부 큐에다 추가해주는 함수다.
packetQueue의 크기가 10개 초과인 경우 오래된 큐를 날려버려야 한다.
다행히 Queue는 FIFO의 속성을 가지고 있어, Dequeue라는 함수로 가볍게 추출 및 제거가 가능하다.
Dequeue로 맨앞의 오래된 큐를 날려버리고 새로운 큐를 Enqueue로 등록 하면 된다.
큐의 크기가 10이하일 경우 그냥 추가만 해주면 되게끔 했다.
ProcessPacket()은 받아온 패킷을 실행 해주는 것이다.
큐에 아무것도 없다면 미정의 동작을 막기위해 리턴 해주고, 아니라면 처리 로그를 띄워줌과 동시에
큐를 없애준다.



8-4 : C++ 문제 1
단어 길이 기준 정렬기

void SortWord(vector<string>& words)
{
    sort(words.begin(), words.end(),
        [](string& a, string& b)
        {
            if (a.length() == b.length())
            {
                return a < b;
            }

            return a.length() < b.length();
        }
        );
}

int main()
{
   vector<string> str = { "apple", "kiwi", "banana", "an", "and", "ant"};

    SortWord(str);

    for (auto s : str)
    {
        cout << s << endl;
    }
}

- 핵심 로직 및 설명
핵심 : 람다를 사용한 정렬 조건 설정
설명 : 
람다 라는걸 처음 써보는 문제이다.
람다는 즉석에서 함수를 만들어서 바로 쓸 수 있는 문법이다. 이를 이용해 연산자 오버로딩과 같은 함수를
정렬 기준으로 넣어서 정렬할 수 있도록 했다.
단순히 sort 함수를 쓴 것 뿐인 함수이지만, 조건 설정은 '단어의 길이가 짧게, 같다면 사전 순서대로'이다.
비교할 두 단어의 길이를 보고 같다면 알파벳 순으로 비교한 결과를, 그 이외의 경우에는 길이 순서대로
오름차순으로 정렬했다.
and와 ant 같은 한글자를 제외하고 같은 알파벳을 가진 경우도 이에 대응할 수 있도록 설계했다.



8-5 : C++ 문제 2
컴포넌트 기반 상태 업데이트 시스템

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Component
{
public:
	Component() {}
	virtual void Update()
	{
		cout << "기본 업데이트" << endl;
	}
	~Component()
	{
		cout << "컴포넌트 소멸" << endl;
	}
};

class HealthComponent : public Component
{
public:
	HealthComponent() {}
	void Update() override
	{
		cout << "체력 업데이트" << endl;
	}
};

class PositionComponent : public Component
{
public:
	PositionComponent() {}
	void Update() override
	{
		cout << "위치 업데이트" << endl;
	}
};

class AIComponent : public Component
{
public:
	AIComponent() {}
	void Update() override
	{
		cout << "AI 업데이트" << endl;
	}
};

class ComponentManager
{
private:
	vector<Component*> allComponent;

public:
	ComponentManager()
	{
		allComponent.push_back(new Component());
		allComponent.push_back(new HealthComponent());
		allComponent.push_back(new PositionComponent());
		allComponent.push_back(new AIComponent());
	}

	void AllComponentUpdate()
	{
		for (auto c : allComponent)
		{
			c->Update();
		}
	}

	~ComponentManager()
	{
		for (auto c : allComponent)
		{
			delete c;
		}
	}
};

int main()
{
	ComponentManager cm;

	cm.AllComponentUpdate();
}

- 핵심 로직 및 설명
핵심 : 상속 및 다형성을 통한 컴포넌트 순회
설명 :
이번문제에 쓰인 로직은 팀 프로젝트때에 사용했던 로직이라 수월했다.
Component 클래스를 부모로 Health, Position, AI의 상속 클래스를 만들고, Update함수를 오버로딩 해서 사용했다.
그리고 모든 컴포넌트를 담아두고 사용할 클래스, ComponentManager를 만든다.
ComponentManager는 모든 컴포넌트를 사용해야 함으로, 다형성을 활용한 Component 포인터 벡터를 멤버변수로 해서,
생성시에 Component 포인터 하나당 사용할 컴포넌트를 넣어준다. 나머지는 AllComponentUpdate 함수에서 각 컴포넌트를 돌며 업데이트 해주는 코드를 넣어주고, 포인터로 동적할당을 해준 만큼 소멸자에서도 확실하게 할당된 포인터들을 해제해준다.
main에서는 저렇게 사용해주면 간단하다.