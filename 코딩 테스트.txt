2-1
문제: 특정 문자 제거

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

char* solution(const char* my_string, const char* letter) {
    
    int length = strlen(my_string);
    int index = 0;
    char* array2[length];
    
    for(int i = 0; i<length;i++)
    {
        if(my_string[i] != letter[0])
        {
            array2[index] = my_string[i];
            index++;
        }
    }
    
    char* result = (char*)malloc(index + 1);
    
    for(int i = 0; i< index; i++)
    {
        result[i] = array2[i];
    }
    
    result[index] = '\0';
    
    
    return result;
}

- 핵심 로직 및 설명

필터링 된 만큼만 만드는것. my_string에서 타겟 문자를 제외한 문자를 담고있는 배열이 array2.
여기서 테스트 케이스 2번째 경우 처럼 타겟문자가 여러개가 있을 수 있으니
필터링 된 문자의 개수를 나타내는 index가 필요함. 지역 변수로 선언된 상태에서 배열의 앞주소를 넘기면
미정의 동작이 일어남으로 넘겨주는 배열은 동적할당이 필요하다.
따라서 result에 index를 이용한 동적할당을 해주고, 널문자 공간을 위해 +1을 해준다.
나머지는 문자를 옮겨주기만 하면 된다. 마지막 원소로 널문자를 넣어주면 완성.



2-2 : C# 문제 1
배열 자르기

using System;

public class Solution {
    public int[] solution(int[] numbers, int num1, int num2) {
        int length = num2 - num1 +1;
        int[] result = new int[length];
        
        for(int i =0; i < length ;i++)
        {
            result[i] = numbers[num1+i];
        }
        
        return result;
    }
}

-핵심 로직 및 설명
범위 내의 원소를 가져오는 것이 핵심. 그러면 일단 범위의 크기를 알아야하고,
그 크기에 맞게 자리를 만들어 주면 된다. num1 < num2 이니 범위의 크기는 num2 - num1 +1.
length에 초기화 시켜주고, length에 맞게 new int[]로 동적 할당해준다. 이후 for문으로 length 만큼 반복하는데
이때 복사과정에서 result[i] = numbers[num1+i]가 필요하다. num1은 범위의 첫 인덱스이다. 그곳에서 부터
length 만큼 반복 하면 범위내의 숫자들을 성공적으로 복사 가능하다. 반환 까지 해주면 끝.



2-3 : C# 문제 2
사용자 금지어 필터

using System;

public class Solution
{
    public string solution(string content, string bannedTags)
    {
        string[] words = content.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        string[] banned1 = bannedTags.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        string[] banned2 = bannedTags.Split(',', StringSplitOptions.RemoveEmptyEntries);

        foreach(string word in words)
        {
            foreach(string bannedTag in banned1)
            {
                if(word == bannedTag)
                {
                    return "BLOCK";
                }
            }
        }

        foreach (string word in words)
        {
            foreach (string bannedTag in banned2)
            {
                if (word == bannedTag)
                {
                    return "BLOCK";
                }
            }
        }

        return "ALLOW";
    }
}


-핵심 로직 및 설명
중요 포인트는 '어떻게 인식할 것인가?' 이다. content는 단순한 문장이 들어있다고 치지만, 
bannedTags는 다르다. 여러개가 동시에 있을 수도 있고, 어떤 방식으로 단어가 나뉘어져 있는지도 모른다.
제일 대표적인 공백과 콤마로 케이스를 나누어서 판단했다. Split옵션으로 아무런 값이 없는 것은 무시하도록
설정 해서, 순수하게 단어들 끼리로만 비교하도록 했다. 단어들을 각 배열에 넣어준다음, 공백문자로 나눈 케이스
콤마로 나눈 케이스들을 비교해서 한번 걸리면 "BLOCK"을, 전부 통과하면 ALLOW를 string으로 반환 하도록
했다.


2-4 : C++ 문제 1
문자열 내 p와 y의 개수

#include <string>
#include <iostream>
using namespace std;

bool solution(string s)
{
    int countp = 0;
    int county = 0;
    
    for(int i = 0; i< s.size();i++)
    {
        if(s[i] == 'p' || s[i] == 'P')
        {
            countp++;
        }
        else if(s[i] == 'y' || s[i] == 'Y')
        {
            county++;
        }
    }
    
    if(countp == county)
    {
       return true;
    }
    else if(countp != county)
    {
        return false;
    }
}


- 핵심 로직 및 설명
p와 y의 개수를 대소문자 구분 없이 대조하여 true/false를 반환 하는 bool타입 함수이다.
가장 중요한 점은 '대소문자 구분 없이'. p와 y의 경우를 대문자 또는 소문자로 나누어 or 로 연산하여 true라면
각각의 카운트를 1씩 증가 시킨다. 마지막은 카운터를 비교하여 조건에 맞으면 true 아니면 false로 반환한다.



2-5 : C++ 문제 2
해시맵을 활용한 중복 문자 제거

