2-1
문제: 특정 문자 제거

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

char* solution(const char* my_string, const char* letter) {
    
    int length = strlen(my_string);
    int index = 0;
    char* array2[length];
    
    for(int i = 0; i<length;i++)
    {
        if(my_string[i] != letter[0])
        {
            array2[index] = my_string[i];
            index++;
        }
    }
    
    char* result = (char*)malloc(index + 1);
    
    for(int i = 0; i< index; i++)
    {
        result[i] = array2[i];
    }
    
    result[index] = '\0';
    
    
    return result;
}

- 핵심 로직 및 설명

필터링 된 만큼만 만드는것. my_string에서 타겟 문자를 제외한 문자를 담고있는 배열이 array2.
여기서 테스트 케이스 2번째 경우 처럼 타겟문자가 여러개가 있을 수 있으니
필터링 된 문자의 개수를 나타내는 index가 필요함. 지역 변수로 선언된 상태에서 배열의 앞주소를 넘기면
미정의 동작이 일어남으로 넘겨주는 배열은 동적할당이 필요하다.
따라서 result에 index를 이용한 동적할당을 해주고, 널문자 공간을 위해 +1을 해준다.
나머지는 문자를 옮겨주기만 하면 된다. 마지막 원소로 널문자를 넣어주면 완성.



2-2 : C# 문제 1
배열 자르기

using System;

public class Solution {
    public int[] solution(int[] numbers, int num1, int num2) {
        int length = num2 - num1 +1;
        int[] result = new int[length];
        
        for(int i =0; i < length ;i++)
        {
            result[i] = numbers[num1+i];
        }
        
        return result;
    }
}

-핵심 로직 및 설명
범위 내의 원소를 가져오는 것이 핵심. 그러면 일단 범위의 크기를 알아야하고,
그 크기에 맞게 자리를 만들어 주면 된다. num1 < num2 이니 범위의 크기는 num2 - num1 +1.
length에 초기화 시켜주고, length에 맞게 new int[]로 동적 할당해준다. 이후 for문으로 length 만큼 반복하는데
이때 복사과정에서 result[i] = numbers[num1+i]가 필요하다. num1은 범위의 첫 인덱스이다. 그곳에서 부터
length 만큼 반복 하면 범위내의 숫자들을 성공적으로 복사 가능하다. 반환 까지 해주면 끝.



2-3 : C# 문제 2
사용자 금지어 필터

using System;

public class Solution
{
    public string solution(string content, string bannedTags)
    {
        string[] words = content.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        string[] banned1 = bannedTags.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        string[] banned2 = bannedTags.Split(',', StringSplitOptions.RemoveEmptyEntries);

        foreach(string word in words)
        {
            foreach(string bannedTag in banned1)
            {
                if(word == bannedTag)
                {
                    return "BLOCK";
                }
            }
        }

        foreach (string word in words)
        {
            foreach (string bannedTag in banned2)
            {
                if (word == bannedTag)
                {
                    return "BLOCK";
                }
            }
        }

        return "ALLOW";
    }
}


-핵심 로직 및 설명
중요 포인트는 '어떻게 인식할 것인가?' 이다. content는 단순한 문장이 들어있다고 치지만, 
bannedTags는 다르다. 여러개가 동시에 있을 수도 있고, 어떤 방식으로 단어가 나뉘어져 있는지도 모른다.
제일 대표적인 공백과 콤마로 케이스를 나누어서 판단했다. Split옵션으로 아무런 값이 없는 것은 무시하도록
설정 해서, 순수하게 단어들 끼리로만 비교하도록 했다. 단어들을 각 배열에 넣어준다음, 공백문자로 나눈 케이스
콤마로 나눈 케이스들을 비교해서 한번 걸리면 "BLOCK"을, 전부 통과하면 ALLOW를 string으로 반환 하도록
했다.


2-4 : C++ 문제 1
문자열 내 p와 y의 개수

#include <string>
#include <iostream>
using namespace std;

bool solution(string s)
{
    int countp = 0;
    int county = 0;
    
    for(int i = 0; i< s.size();i++)
    {
        if(s[i] == 'p' || s[i] == 'P')
        {
            countp++;
        }
        else if(s[i] == 'y' || s[i] == 'Y')
        {
            county++;
        }
    }
    
    if(countp == county)
    {
       return true;
    }
    else if(countp != county)
    {
        return false;
    }
}


- 핵심 로직 및 설명
p와 y의 개수를 대소문자 구분 없이 대조하여 true/false를 반환 하는 bool타입 함수이다.
가장 중요한 점은 '대소문자 구분 없이'. p와 y의 경우를 대문자 또는 소문자로 나누어 or 로 연산하여 true라면
각각의 카운트를 1씩 증가 시킨다. 마지막은 카운터를 비교하여 조건에 맞으면 true 아니면 false로 반환한다.



2-5 : C++ 문제 2
해시맵을 활용한 중복 문자 제거

#include <iostream>
#include <unordered_map>
using namespace std;

string Solution(const string str)
{
    unordered_map<char, int> map;

    for (int i = 0; i < str.length(); i++)
    {
        map[str[i]] = i;
    }

    string result;

    for (int i = 0; i < str.length(); i++)
    {
        if (map[str[i]] == i)
        {
            result.push_back(str[i]);
        }
    }

    return result;
}


-핵심 로직 및 설명
해시맵은 내부적으로 hash<T>를 사용한다. 같은 키에서 충돌이 일어나면 덮어씌워지는 특성을 이용해
마지막으로 나온 문자를 추출한다. 문자열의 원소를 키로, 그것의 인덱스를 값으로 해서 제일 마지막에 나온
인덱스를 저장하게 된다. 이후 그에 맞춰 인덱스 값이 같다면 result에 넣어서 반환시키면 된다.

================================================================

3-1
문자열 안에 문자열

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

int solution(const char* str1, const char* str2) {
    int length1 = strlen(str1);
    int length2 = strlen(str2);
    
    for(int i = 0; i< length1 - length2 +1 ; i++)
    {
        bool exist = true;
        for(int j = 0; j < length2 ; j++)
        {
            if(str1[i+j] != str2[j])
            {
                 exist = false;
	     break;
            }
        }
        if(exist)
        {
            return 1;
        }
    }
    return 2;
}


- 핵심 로직 및 설명
사용한 로직은 슬라이딩 윈도우. 검사의 주체가 되는 str2를 한칸씩 옆으로 옮겨가며 str2의 크기 만큼 반복해서
원소를 비교하는 방식으로 진행했다. 각 배열의 크기를 구해서 변수에 넣어놓고, 슬라이딩 윈도우 시작.
exist를 기본 true로 해두고, 두 원소를 비교중 불일치가 나온다면 false로 만들고 중지, 다음 반복으로 넘어가게끔
했다. 결과적으로 전부 다 돌았을때 exist가 아직 true라면 존재 한다는 것이니 1을 반환, 다돌았는데도 없으면 2를
반환 한다.



3-2 : C# 문제 1
대문자와 소문자

using System;
using System.Text;

public class Solution {
    public string solution(string my_string) {
       
        StringBuilder result = new StringBuilder();
        
        for(int i = 0 ; i < my_string.Length ; i++)
        {
            if(char.IsUpper(my_string[i]))
            {
                result.Append(char.ToLower(my_string[i]));
            }
            else
            {
                result.Append(char.ToUpper(my_string[i]));
            }
        }
        return result.ToString();
        
    }
}


- 핵심 로직 및 설명
C#은 C++과 다르게 '불변' 속성을 가지고 있어서 push_back을 할 수 없다. 그래서 따로 만들기 위해서는 StringBuilder가 필요하다.
using System.Text를 선언해서 StringBuilder를 사용할 수 있게끔 만들고, 이를 이용해서 바꾼 문자열을 반환 한다.
my_string의 크기 만큼 반복하면서 각 원소가 대문자면 소문자로, 소문자면 대문자로 result에 저장되게끔 하고,
반환 할땐 ToString()을 써서 string으로 반환 시켜 준다.



3-3 : C# 문제 2
숫자 자동 집계 시스템

using System;
using System.Collections.Generic;
using System.Linq;

public class Solution
{
    public List<(int number, int count)> solution(int[] numbers)
    {
        Dictionary<int ,int> dict = new Dictionary<int, int> ();
        
        foreach(int i in numbers)
        {
            if(dict.ContainsKey(i))
            {
                dict[i]++;
            }
            else
            {
                dict[i] = 1;
            }
        }

        List<(int number, int count)> result = dict
            .OrderByDescending(pair => pair.Value)
            .Select(pair => (pair.Key, pair.Value))
            .ToList();

        return result;
    }
}

- 핵심 로직
Tuple은 수정이 안되는 '불변'속성을 가지고 있다. 따라서 다른곳에서 카운팅을 하고 그 값을 저장해야 한다.
Dictionary를 이용해 numbers의 숫자를 키값으로 받고, 있으면 숫자를 1올리고, 없으면 1을 저장한다.
Linq의 OrderByDescending을 이용해 count값 기준 내림차순 정렬해준 다음, Select를 이용해 튜플로 바꿔준다음
리스트로 변환 시켜주고 반환 하면 끝이다.



3-4 : C++ 문제 1
중복된 문자 제거

#include <string>
#include <unordered_map>

using namespace std;

string solution(string my_string) {
    
    unordered_map<char, int> map;
    string result;
    
    for(int i = 0; i< my_string.length() ; i++)
    {
        if(map.find(my_string[i]) == map.end())
        {
            map[my_string[i]] = i;
            result.push_back(my_string[i]);
        }
    }
    return result;
}


- 핵심 로직 및 설명
설명을 적으면서 든 생각이지만, 해시맵이 아니라 일반 맵을 써도 됐을것 같다는 생각이 들었다.
다만 쓸데없는 동작이 있을 것 같아 해시맵을 사용했다.
my_string의 원소를 비교 하면서 그 문자가 해시맵에 존재하는지 확인 후, 없으면 인덱스와 함께 추가,
result에 바로 넣어 버린다. 결과적으로 첫 등장한 문자만 순서대로 result에 들어가서 반환 된다.



3-5 : C++ 문제 2
괄호 내 문자열 뒤집기

#include <string>
#include <vector>

using namespace std;

vector<int> solution(vector<int> arr) {
    
    vector<int> stk;
    
    for(int i = 0; i< arr.size(); i++)
    {
        if(!stk.empty() && stk.back() == arr[i])
        {
            stk.pop_back();
        }
        else
        {
            stk.push_back(arr[i]);
        }
    }
    
    if(!stk.empty())
    {
        return stk;
    }
    else
    {
        stk.push_back(-1);
        return stk;
    }
}


- 핵심 로직 및 설명
조건의 분기를 잘 보면 stk의 마지막 요소가 같은 경우에는 같은 행동을 한다.
쓸데없이 분기를 만들기 보다는 한번에 통일해서 처리하는 것이 가독성에 더 좋다고 생각했다.
arr의 크기만큼 반복하는 동안 stk이 비지 않은 상태에서 마지막 요소가 arr[i]와 같으면 없애버리고,
나머지의 경우에는 그냥 넣어주기로 했다. 
마지막에 함정이 있는데, stk이 빈 상태가 아니라면 그대로 반환 하고, 비어있다면 [-1]을 반환해야하는데,
-1을 stk안에 넣어주고 반환 시켜야한다. 반환형이 vector<int>이므로 vector안에다 넣어준다음 반환해야
오류가 나지 않는다.

=================================================================

4-1
OX퀴즈 판별기

char* Solution(const char* question)
{
	int x1, y1, z1;
	float x2, y2, z2;
	char op;
	
	if (sscanf(question, "%d %c %d = %d", &x1, &op, &y1, &z1) == 4)
	{
		switch (op)
		{
		case '+': return (x1 + y1 == z1) ? "O" : "X"; break;
		case '-': return (x1 - y1 == z1) ? "O" : "X"; break;
		case '*': return (x1 * y1 == z1) ? "O" : "X"; break;
		case '/': return (y1 != 0 && x1 / y1 == z1) ? "O" : "X"; break;
		}
	}
	else if (sscanf(question, "%d %c %f = %f", &x1, &op, &y2, &z2) == 4)
	{
		switch (op)
		{
		case '+': return (x1 + y2 == z2) ? "O" : "X"; break;
		case '-': return (x1 - y2 == z2) ? "O" : "X"; break;
		case '*': return (x1 * y2 == z2) ? "O" : "X"; break;
		case '/': return (y2 != 0 && x1 / y2 == z2) ? "O" : "X"; break;
		}
	}
	else if (sscanf(question, "%f %c %d = %f", &x2, &op, &y1, &z2) == 4)
	{
		switch (op)
		{
		case '+': return (x2 + y1 == z2) ? "O" : "X"; break;
		case '-': return (x2 - y1 == z2) ? "O" : "X"; break;
		case '*': return (x2 * y1 == z2) ? "O" : "X"; break;
		case '/': return (y1 != 0 && x2 / y1 == z2) ? "O" : "X"; break;
		}
	}
	else if (sscanf(question, "%f %c %f = %f", &x2, &op, &y2, &z2) == 4)
	{
		switch (op)
		{
		case '+': return (x2 + y2 == z2) ? "O" : "X"; break;
		case '-': return (x2 - y2 == z2) ? "O" : "X"; break;
		case '*': return (x2 * y2 == z2) ? "O" : "X"; break;
		case '/': return (y2 != 0 && x2 / y2 == z2) ? "O" : "X"; break;
		}
	}
}


- 핵심 로직 및 설명
내가 짠 코드중에서 가장 더러운 코드라고 볼 수 있을 것 같다.
더러워진 이유는 단 하나. 문제에는 숫자가 어떤 자료형이 들어올지를 알려주지 않았다. 그렇기에
임의로 int와 float의 경우를 전부 판단해서 작성하였다. 이 부분 양해 바람.
첫번째로 int형의 숫자들과 float형의 숫자들, 연산자를 받아올 char 변수까지 선언해주고,
sscanf를 통해 question의 포맷대로 각 숫자와 연산자를 변수에 저장 시키고, 제대로 되었다면 if문으로 진입
만약 자료형이 달라 하나라도 잘못 받아오게 되면 4가 아니게 될테니 다음 포맷으로 가서 검사하도록 설계했다.
다음, 받아온 연산자를 switch문으로 숫자들을 연산한 결과(bool)를 삼항 연산자로 판단해서 맞으면 O, 틀리면 X
char* 로 반환 해주게끔 했다.



4-2 : C# 문제 1
숫자 문자열 정렬 + 유효성 필터

public int[] solution(string my_string)
{
    List<int> list = new List<int>();

    for (int i = 0; i < my_string.Length; i++)
    {
        if (char.IsDigit(my_string[i]))
        {
            list.Add(my_string[i] - '0');
        } 
    }

    list.Sort();

    int[] result = new int[list.Count];

    for(int i = 0; i < list.Count;i++)
    {
        result[i] = list[i];
    }

    return result;
}


- 핵심 로직 및 설명
일단 숫자를 받아 정렬 시켜줄 List<int>를 만들고, 
my_string의 원소들을 읽어 숫자라면 int형으로 바꿔서 넣어준다.
그다음 sort()함수를 이용해서 오름차순 정렬해주고, list의 크기만큼 정수배열을 만들어
차례차례 넣어주고 반환 해주면 끝이다.



4-3 : C# 문제 2
사용자의 사운드 설정을 저장하고 불러오는 클래스를 설계하세요.

public class SoundOption
{
    float BGM = 100.0f;
    float SE = 100.0f;

    public void LoadSetting(Dictionary<string,float> dict)
    {
        int index = 0;
        float[] values = new float[2];

        foreach(var key in dict.Keys)
        {
            values[index++] = dict[key];
        }

        BGM = values[0];
        SE = values[1];
    }

    public Dictionary<string,float> SaveOption()
    {
        var saveOption = new Dictionary<string,float>();

        saveOption["BGM"] = BGM;
        saveOption["SE"] = SE;

        return saveOption;
    }

    public void SetBGMVolume(float rate)
    {
        BGM = rate;
    }

    public void SetSEVolume(float rate)
    {
        SE = rate;
    }
}


- 핵심 로직 및 설명
설명에 앞서서 딕셔너리 위주로 저장, 불러오기를 구현했다.
일단 BGM, SE 수치를 저장할 float형 변수를 선언해서 비교를 위한 기본값 100을 넣어 주었다.
BGM과 SE를 설정해주는 함수는 거의 한줄로 끝나기 때문에 어려울게 없었다.
문제는 Dictionary. 통계 강의를 들으면서 어렴풋이 기억나는 형식이지만, 용법을 모른다.

=================================================================

10-1
일정 구간별 난이도 판별기

typedef struct
{
	int start;
	int finish;
	int difficult;
}Schedule;

float Solution(Schedule schedule[], int size)
{
	int startTime = 10000;
	int finishTime = 0;

	for (int i = 0; i < size; i++)
	{
		if (schedule[i].start < startTime)
		{
			startTime = schedule[i].start;
		}
		if (schedule[i].finish > finishTime)
		{
			finishTime = schedule[i].finish;
		}
	}

	int timeLine[24] = {0};

	for (int i = 0; i < size; i++)
	{
		for (int t = schedule[i].start; t < schedule[i].finish; t++)
		{
			if (timeLine[t] < schedule[i].difficult)
			{
				timeLine[t] = schedule[i].difficult;
			}
		}
	}

	int totalDiff = 0;
	int totalTime = 0;

	for (int t = startTime; t < finishTime; t++)
	{
		if (timeLine[t] > 0)
		{
			totalDiff += timeLine[t];
			totalTime++;
		}
	}

	return (float)totalDiff / totalTime;

}


- 핵심 로직 및 설명
중요포인트는 '어떻게 최대 난이도를 갱신 할 것인가' 이다.
구조체를 만들어 배열 처리를 간단하게 해주고, 전체 스케쥴의 시작 시간, 종료 시간을 구해준다.
이렇게 함으로써 전체 스케쥴 시간의 구간을 구할 수 있게 된다. 이를 이용해서,
받은 배열을 순회하면서 각 스케쥴의 난이도를 timeLine배열 안에 저장한다. timeLine은 크기가 24인 배열이고,
인덱스가 시간 정각을 의미한다. 9~11시 라면 이 시간 간극 만큼 반복하면서 timeLine에 난이도를 저장한다.
만약 같은 timeLine에 있는 난이도가 지금 스케쥴의 난이도 보다 높다면 업데이트를 해주고 아니면 넘어가도록 만들었다.
이제 timeLine안에는 시간대별 스케쥴 난이도가 들어가 있다. 이제 이것들을 찾아서 합과 함께 작업 시간을 나눠주면 된다.
아까전에 구한 스케쥴 시작 시간과 종료시간을 이용해 timeLine을 순회 하면서 난이도가 0이상인 것들을
totalDiff안에 더해넣는다. 그와 동시에 totalTime도 1씩 올려준다. 마지막으로 float형으로 바꿔서 결과를 반환 해주면 끝이다.
